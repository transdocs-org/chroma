# 单节点 Chroma：性能与限制

Chroma 的单节点版本设计为易于部署和维护，同时仍然提供满足广泛生产应用场景的稳健性能。

为了帮助您了解单节点 Chroma 是否适合您的使用场景，我们进行了一系列压力测试和性能实验，以探测系统的功能并发现其局限性和边界情况。我们在多种硬件配置下分析了这些边界，以确定哪种部署适合不同的工作负载。

本文档描述了这些发现，以及一些优化 Chroma 部署性能的通用原则。

## 结果摘要

粗略地说，以下是在典型工作负载下，不同 EC2 实例类型上 Chroma 的预期性能：

- 1024 维嵌入向量
- 小型文档（100-200 字）
- 每条记录有三个元数据字段

| 实例类型        | 系统内存 (GB) | 近似最大集合大小 | 平均延迟（查询） | 99.9% 延迟（查询） | 平均延迟（插入，批量大小=32） | 99.9% 延迟（插入，批量大小=32） | 月成本     |
|-----------------|---------------|------------------|------------------|--------------------|-----------------------------|-------------------------------|------------|
| **r7i.2xlarge** | 64            | 15,000,000       | 5ms              | 7ms                | 112ms                       | 405ms                         | $386.944   |
| **t3.2xlarge**  | 32            | 7,500,000        | 5ms              | 33ms               | 149ms                       | 520ms                         | $242.976   |
| **t3.xlarge**   | 16            | 3,600,000        | 4ms              | 7ms                | 159ms                       | 530ms                         | $121.888   |
| **t3.large**    | 8             | 1,700,000        | 4ms              | 10ms               | 199ms                       | 633ms                         | $61.344    |
| **t3.medium**   | 4             | 700,000          | 5ms              | 18ms               | 191ms                       | 722ms                         | $31.072    |
| **t3.small**    | 2             | 250,000          | 8ms              | 29ms               | 231ms                       | 1280ms                        | $15.936    |

<br>

**不推荐**在内存少于 2GB 的系统上部署 Chroma。

请注意，此表中的延迟数据是针对小型集合的。随着集合增大，延迟也会增加：详见下面的 [延迟与集合大小](#延迟与集合大小) 分析。

## 内存与集合大小

Chroma 使用 [`hnswlib`](https://github.com/nmslib/hnswlib) 的一个分支来高效地索引和搜索嵌入向量。HNSW 算法要求将嵌入索引驻留在系统 RAM 中，以便进行查询或更新。

因此，可用系统内存的大小定义了 Chroma 集合（或多个集合，如果它们被同时使用）大小的上限。如果集合增长超过可用内存，插入和查询延迟会迅速飙升，因为操作系统开始将内存交换到磁盘。索引的内存布局不适合交换，系统很快变得无法使用。

因此，用户应始终计划预留足够的 RAM 来容纳预期的嵌入总数。

为了分析所需 RAM 的大小，我们在不同大小的 EC2 实例上启动了 Chroma 实例，然后插入嵌入直到每个系统变得无响应。如预期，这一故障点与 RAM 和嵌入数量呈线性关系。

对于每个嵌入有 1024 维嵌入向量、三个元数据记录和一个小文档的情况，公式为 `N = R * 0.245`，其中 `N` 是最大集合大小（百万），`R` 是所需系统内存（GB）。请记住，您还需要预留至少 1GB 的内存用于系统其他需求，再加上 Chroma 所需的内存。

这一模式在测试到 700 万个嵌入时仍然成立。此时 Chroma 仍然快速且稳定，我们并未发现 Chroma 数据库大小的严格上限。

## 磁盘空间与集合大小

Chroma 会将每个集合持久化地保存到磁盘。所需空间是保存 HNSW 嵌入索引所需空间和用于存储文档和嵌入元数据的 sqlite 数据库所需空间的组合。

持久化 HNSW 索引的计算方式与计算 RAM 大小类似。经验法则是，确保系统的存储空间至少与 RAM 一样大，再加上几 GB 以考虑操作系统和其他应用程序的开销。

sqlite 数据库所需的存储空间高度可变，完全取决于是否在 Chroma 中保存文档和元数据，以及它们的大小。作为单一数据点，一个包含约 4 万个 1000 字文档和约 60 万个元数据条目的集合的 sqlite 数据库约为 1.7GB。

对于元数据数据库的大小没有严格的上限：sqlite 本身支持达到 TB 级的数据库，并且可以有效地分页到磁盘。

在大多数实际用例中，HNSW 索引在 RAM 中的大小和性能很可能在元数据数据库成为限制因素之前就成为 Chroma 集合大小的瓶颈。

## 延迟与集合大小

随着集合的增大和索引大小的增长，插入和查询都需要更长时间才能完成。增加的速度开始相对平缓，然后大致呈线性增长，拐点和斜率取决于 CPU 的数量和速度。某些实例（如 `t3.2xlarge`）图表末尾的极端峰值发生在实例达到内存限制时。

### 查询延迟

{% MarkdocImage lightSrc="/query_latency_1_0_10_light.png" darkSrc="/query_latency_1_0_10.png" alt="查询延迟性能" %}
{% /MarkdocImage %}

### 插入延迟

{% MarkdocImage lightSrc="/insert_latency_1_0_10_light.png" darkSrc="/insert_latency_1_0_10.png" alt="插入延迟性能" %}
{% /MarkdocImage %}

{% note type="tip" title="" %}
如果您使用多个集合，其性能基于所有集合的嵌入总数来看非常相似。将集合拆分成多个小集合不会有所帮助，但也不会造成损害，只要它们都能同时装入内存即可。
{% /note %}

## 并发

系统可以并行处理并发操作。对于插入操作，由于写入会被写入日志并在每 N 次操作后刷新，因此平均延迟不会随着写入者数量的增加而波动，但会随着批量大小的增加而增加，因为更大的批量更有可能触及刷新阈值。查询操作在实例可用 vCPU 数量范围内可以并行化，超过后将开始排队，从而导致延迟线性增加。

{% MarkdocImage lightSrc="/concurrent_writes_1_0_10_light.png" darkSrc="/concurrent_writes_1_0_10.png" alt="并发写入" %}
{% /MarkdocImage %}

{% MarkdocImage lightSrc="/concurrent_queries_1_0_10_light.png" darkSrc="/concurrent_queries_1_0_10.png" alt="并发查询" %}
{% /MarkdocImage %}

有关在并发受您控制时（例如插入批量数据时）优化用户数量以获得最大吞吐量的讨论，请参见下面的 [插入吞吐量](#插入吞吐量) 部分。

# CPU 速度、核心数量与类型

{% MarkdocImage lightSrc="/cpu_mean_query_latency_1_0_10_light.png" darkSrc="/cpu_mean_query_latency_1_0_10.png" alt="CPU 平均查询延迟" %}
{% /MarkdocImage %}

# 插入吞吐量

一个经常相关的问题是：给定要插入的批量数据，最快可以多快完成，以及快速插入大量数据的最佳方法是什么？

第一个需要考虑的重要因素是并发插入请求的数量。

如上文 [并发](#并发) 部分所述，插入吞吐量确实受益于增加的并发。第二个需要考虑的因素是每个请求的批量大小。由于较小批量的高开销，性能随着批量大小增加而提升，直到达到 CPU 饱和度。在达到 CPU 饱和度后，大约在批量大小为 150 时吞吐量趋于稳定。

实验验证了这一点：在批量大小为 100-500 之间时，整体吞吐量（跨批量大小和请求数量的总嵌入数）保持相对稳定：

{% MarkdocImage lightSrc="/concurrent_inserts_1_0_10_light.png" darkSrc="/concurrent_inserts_1_0_10.png" alt="并发插入" %}
{% /MarkdocImage %}

鉴于较小的批量具有更低且更一致的延迟，且不太可能导致超时错误，我们建议使用此曲线较小侧的批量：50 到 250 之间的任何值都是合理的选择。

## 结论

只要部署在合适的硬件上，用户可以放心依赖 Chroma 来处理接近千万级嵌入的应用场景。其平均和上限延迟对于读写操作来说都使其成为一个良好的平台，适用于除最大型 AI 应用之外的所有场景，支持潜在的数千名同时在线用户（取决于您的应用程序后端访问模式）。

然而，作为一种单节点解决方案，它不会无限扩展。如果您发现您的需求超出了本分析中列出的参数，我们非常希望收到您的反馈。请填写 [此表单](https://airtable.com/appqd02UuQXCK5AuY/pagr1D0NFQoNpUpNZ/form)，我们将您添加到一个专门的 Slack 工作区，以支持生产用户。我们很乐意帮助您思考系统设计，无论 Chroma 是否适合您的系统，或者您是否适合我们即将推出的分布式云服务。